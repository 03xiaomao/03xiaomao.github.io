[{"title":"go-mysql","url":"/mysql/","content":" Go — mysql\n 1. 初始化连接\n// 定义一个全局变量\nvar db *sql.DB\n\n// 定义一个输出话数据库的函数\nfun initDB() err error &#123;\n    dsn := \"user:password@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4&amp;parseTime=True\"\n    // 不会校验账号密码是否正确\n    // 注意 这里不要使用:=, 我们是给全局变量赋值，然后在main函数中使用全局变量db\n    db, err = sql.Open(\"mysql\", dsn)\n    if err != nil &#123;\n        return err\n    &#125;\n    // 尝试与数据库建立连接（校验dsn是否正确）\n    err = db.Ping()\n    if err != nil &#123;\n        return err\n    &#125;\n    return nil\n&#125;\n\nfunc main() &#123;\n    err := initDB() // 调用输出化数据库的函数\n    if err != nil &#123;\n        fmt.Printf(\"init db failed, err:%v\\n\",err)\n        return\n    &#125;\n&#125;\n其中sql.DB是表示连接的数据库对象（结构体实例），它保存了连接数据库相关的所有信息。它内部维护着一个具有零到多个底层连接的连接池，它可以安全地被多个goroutine同时使用。\nSetMaxOpenConns\nfunc (db *DB) SetMaxOpenConns(n int)\nSetMaxOpenConns设置与数据库建立连接的最大数目。 如果n大于0且小于最大闲置连接数，会将最大闲置连接数减小到匹配最大开启连接数的限制。 如果n&lt;=0，不会限制最大开启连接数，默认为0（无限制）。\nSetMaxIdleConns\nfunc (db *DB) SetMaxIdleConns(n int)\nSetMaxIdleConns设置连接池中的最大闲置连接数。 如果n大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。 如果n&lt;=0，不会保留闲置连接。\n 2. CRUD\n 2.1 建库建表\n我们先在MySQL中创建一个名为sql_test的数据库\nCREATE DATABASE sql_test;\n进入该数据库\nuse sql_test;\n执行以下命令创建一张用于测试的数据表：\nCREATE TABLE &#96;user&#96; (\n\t&#96;id&#96; BIGINT(20) NOT NULL AUTP_INCREMENT,\n\t&#96;name&#96; VARCHAR(20) DEFAULT &#39;&#39;,\n\t&#96;age&#96; INT(11) DEFAULT &#39;0&#39;,\n\tPRIMARY KEY(&#96;id&#96;)\n)ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4;\n 2.2 查询\n为了方便查询，我们事先定义好一个结构体来存储user表的数据。\ntype user struct &#123;\n\tid int\n\tage int\n\tname string\n&#125;\n单行查询\n单行查询db.QueryRow()执行一次查询，并期望返回最多一行结果（即Row）。QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误。（如：未找到结果）\nfunc (db *DB) QueryRow(query string, args ...interface&#123;&#125;) *Row\n具体示例代码：\n// 查询单条数据示例\nfunc queryRowDemo() &#123;\n    sqlStr := \"select id, name, age from user where id=?\"\n    \n    var u user\n    // 非常重要：确保QueryRow之后调用Scan方法，否则持有的数据库链接不会被释放\n    err := db.QueryRow(sqlstr, 1).Scan(&amp;u.id, &amp;u.name, &amp;u.age)\n    if err != nil &#123;\n        fmt.Printf(\"scan failed, err:%v\\n\", err)\n        return\n    &#125;\n    fmt.Printf(\"id:%d name:%s age:%d\\n\", u.id, u.name, u.age)\n&#125;\n多行查询\n多行查询db.Query()执行一次查询，返回多行结果（即Rows），一般用于执行select命令。参数args表示query中的占位参数。\nfunc (db *DB) Query(query string, args ...interface&#123;&#125;) (*Rows, error)\n具体示例代码：\n// 查询多条数据示例\nfunc queryMultiRowDemo() &#123;\n    sqlStr := \"select id, name, age from user where id > ?\"\n    rows, err := db.Query(sqlStr, 0)\n    if err != nil &#123;\n        fmt.Printf(\"query failed, err:%v\\n\", err)\n        return\n    &#125;\n    // 非常重要：关闭rows释放持有的数据库链接\n    defer rows.Close()\n    \n    // 循环读取结果集中的数据\n    for rows.Next() &#123;\n        var u user\n        err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)\n        if err != nil &#123;\n            fmt.Printf(\"scan failed, err:%v\\n\", err)\n        \treturn\n        &#125;\n        fmt.Printf(\"id:%d name:%s age:%d\\n\", u.id, u.name, u.age)\n    &#125;\n&#125;\n插入数据\n插入、更新和删除操作都使用Exec方法。\nfunc (db *DB) Exec(query string, args ...interface&#123;&#125;) (Result, error)\nExec执行一次命令（包括查询、删除、更新、插入等），返回的Result是对已执行的SQL命令的总结。参数args表示query中的占位参数。\n具体插入数据示例代码如下：\n// 插入数据\nfunc insertRowDemo() &#123;\n    sqlStr := \"insert into user(name, age) values (?,?)\"\n    ret, err := db.Exec(sqlStr, \"王五\", 38)\n    if err != nil &#123;\n        fmt.Printf(\"insert failed, err:%v\\n\", err)\n        return\n    &#125;\n    theID, err := ret.LastInsertId()\t// 新插入数据的id\n    if err != nil &#123;\n        fmt.Printf(\"get lastinsert ID failed, err:%v\\n\", err)\n    &#125;\n    fmt.Printf(\"insert success, the id is %d.\\n\", theID)\n&#125;\n 2.3 更新数据\n具体更新数据示例代码如下：\n// 更新数据\nfunc updateRowDemo() &#123;\n    sqlStr := \"update user set age=? where id =?\"\n    ret, err := db.Exec(sqlStr, 39, 3)\n    if err != nil &#123;\n        fmt.Printf(\"update failed, err:%v\\n\", err)\n        return\n    &#125;\n    n, err := ret.RowsAffected() // 操作影响的行数\n    if err != nil &#123;\n        fmt.Printf(\"get RowsAffected failed, err:%v\\n\", err)\n        return\n    &#125;\n    fmt.Printf(\"update success, affected rows:%d\\n\", n)\n&#125;\n 2.4 删除数据\n具体删除数据的示例代码如下：\n// 删除数据\nfunc deleteRowDemo() &#123;\n    sqlStr := \"delete from user where id = ?\"\n    ret, err := db.Exec(sqlStr, 3)\n&#125;\nif err != nil &#123;\n    fmt.Printf(\"delete failed, err:%v\", err)\n    return\n&#125;\nn, err := ret.RowsAffected() // 操作影响的行数\nif err != nil &#123;\n    fmt.Printf(\"get RowsAffected failed, err:%v\\n\", err)\n    return\n&#125;\nfmt.Printf(\"delete success, affected rows:%d\\n\", n)\n 3. MySQL预处理\n 3.1 什么是预处理？\n普通SQL语句执行过程：\n\n客户端对SQL语句进行占位符替换得到完整的SQL语句。\n客户端发送完整SQL语句到MySQL服务端\nMySQL服务端执行完整的SQL语句并将结果返回给客户端。\n\n预处理执行过程：\n\n把SQL语句分成两部分，命令部分与数据部分。\n先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。\n然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。\nMySQL服务端执行完整的SQL语句并将结果返回给客户端。\n\n 3.2 为什么要预处理？\n\n优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。\n避免SQL注入问题。\n\n 3.3 Go实现MySQL预处理\ndatabase/sql中使用下面的Prepare方法来实现预处理操作。\nfunc (db *DB) Prepare(query string) (*Stmt, error)\nPrepare方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态用于之后的查询和命令。返回值可以同时执行多个查询和命令。\n查询操作的预处理示例代码如下：\n// 预处理查询示例\nfunc prepareQueryDemo() &#123;\n    sqlStr := \"select id, name, age from user where id > ?\"\n    stmt, err := db.Prepare(sqlStr)\n    if err != nil &#123;\n        fmt.Printf(\"prepare failed, err:%v\\n\", err)\n        return\n    &#125;\n    defer stmt.Close()\n    rows, err := stmt.Query(0)\n    if err != nil &#123;\n        fmt.Printf(\"query failed, err:%v\\n\", err)\n        return\n    &#125;\n    defer rows.Close()\n    // 循环读取结构集中的数据\n    for rows.Next() &#123;\n        var u user\n        err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)\n        if err != nil &#123;\n            fmt.Printf(\"scan failed, err:%v\\n\", err)\n            return\n        &#125;\n        fmt.Printf(\"id:%d name:%s age:%d\\n\", u.id, u.name, u.age)\n    &#125;\n&#125;\n插入、更新和删除操作的预处理十分类似，这里以插入操作的预处理为例：\n// 预处理插入示例\nfunc prepareInsertDemo() &#123;\n    sqlStr := \"insert into user(name, age) values (?,?)\"\n    stmt, err := db.Prepare(sqlStr)\n    if err != nil &#123;\n        fmt.Printf(\"prepare failed, err:%v\\n\", err)\n        return\n    &#125;\n    defer stmt.Close()\n    _, err = stmt.Exec(\"小王子\", 18)\n    if err != nil &#123;\n        fmt.Printf(\"insert failed, err:%v\\n\", err)\n        return\n    &#125;\n    _, err = stmt.Exec(\"沙河娜扎\", 18)\n    if err != nil &#123;\n        fmt.Prinf(\"insert failed, err:%v\\n\", err)\n        return\n    &#125;\n    fmt.Println(\"insert success.\")\n&#125;\n 3.4 SQL注入问题\n我们任何时候都不应该自己拼接SQL语句！\n这里我们演示一个自行拼接SQL语句的示例，编写一个根据name字段查询user表的函数如下：\n// sql注入示例\nfunc sqlInjectDemo(name string) &#123;\n    sqlStr := fmt.Sprintf(\"select id, name, age from user where name='%s'\", name)  \n    fmt.Printf(\"SQL:%s\\n\", sqlStr)\n    var u user\n    err := db.QueryRow(sqlStr).Scan(&amp;u.id, &amp;u.name, &amp;u.age)\n    if err !=nil &#123;\n        fmt.Printf(\"exec failed, err:%v\\n\", err)\n        return\n    &#125;\n    fmt.Printf(\"user:%#v\\n\", u)\n&#125;\n此时以下输入字符串都可以引发SQL注入问题：\nsqlInjectDemo(\"xxx\" or 1=1#\")\nsqlInjectDemo(\"xxx\" union select * from user #\")\nsqlInjectDemo(\"xxx\" and (select count(*) from user) &lt; 10 #\")\n**补充：**不同的数据库中，SQL语句使用的占位符语法不尽相同。\n\n\n\n数据库\n占位符语法\n\n\n\n\nMySQL\n？\n\n\nPostgreSQL\n$1,$2等\n\n\nSQLite\n？和$1\n\n\nOracle\n:name\n\n\n\n 4. Go实现MySQL事务\n 4.1 什么是事务？\n事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。\n在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。\n 4.2 事务的ACID\n通常事务必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。\n\n\n\n条件\n解释\n\n\n\n\n原子性\n一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n\n一致性\n在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n\n\n隔离性\n数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n\n\n持久性\n事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n\n\n 4.3 事务相关方法\nGo语言中使用以下三个方法实现MySQL中的事务操作。 开始事务\nfunc (db *DB) Begin() (*TX, error)\n提交事务\nfunc (tx *TX) Commit() error\n回滚事务\nfunc (tx *TX) Rollback() error\n 4.4 事务示例\n下面的代码演示了一个简单的事务操作，该事物操作能够确保两次更新操作要么同时成功要么同时失败，不会存在中间状态。\n// 事务操作示例\nfunc transactionDemo() &#123;\n    tx, err := db.Begin() // 开启事务\n    if err != nil &#123;\n        if tx != nil &#123;\n            tx.Rollback() // 回滚\n        &#125;\n        fmt.Printf(\"begin trans failed, err:%v\\n\", err)\n    \treturn\n    &#125;\n    sqlStr1 := \"Update user set age=30 where id=?\"\n    ret1, err := tx.Exec(sqlStr1, 2)\n    if err != nil &#123;\n        tx.Rollback() // 回滚\n        fmt.Printf(\"exec sql1 failed, err:%v\\n\", err)\n        return\n    &#125;\n    affRow1, err := ret1.RowsAffected()\n    if err != nil &#123;\n        tx.Rollback() // 回滚\n        fmt.Printf(\"exec ret1.RowsAffected() failed, err:%v\\n\", err)\n        return\n    &#125;\n    \n    sqlStr2 := \"Update user set age=40 where id=?\"\n    ret2, err := tx.Exec(sqlStr2, 3)\n    if err != nil &#123;\n        tx.Rollback() // 回滚\n        fmt.Printf(\"exec sql2 failed, err:%v\\n\", err)\n        return\n    &#125;\n    affRow2, err := ret2.RowsAffected()\n    if err != nil &#123;\n        tx.Rollback() // 回滚\n        fmt.Printf(\"exec ret1.RowsAffected() failed, err:%v\\n\", err)\n        return\n    &#125;\n    \n    fmt.Println(affRow1, affRow2)\n    if affRow1 == 1 &amp;&amp; affRow2 == 1 &#123;\n        fmt.Println(\"事务提交啦...\")\n        tx.Commit() // 提交事务\n    &#125; else &#123;\n        tx.Rollback()\n        fmt.Println(\"事务回滚啦...\")\n    &#125;\n    fmt.Println(\"exec trans success!\")\n&#125;\n","categories":["mysql"],"tags":[]},{"title":"net-tcp","url":"/net-tcp/","content":" TCP\n 1. TCP三次握手和四次挥手\n1. 建立连接时的三次握手，如下图所示\nhttp://mms0.baidu.com/it/u=3984808339,2926659144&amp;fm=253&amp;app=138&amp;f=PNG&amp;fmt=auto&amp;q=75?w=873&amp;h=500\n1.1第一次握手\n客户端发送一个请求连接报文段，该报文段携带一个0数据的同步位SYN和数据序号为X。进入了SYN_SENT状态等待服务器确定。\n1.2第二次握手\n服务器同意连接，并向客户端发送一个请求连接确认报文段，该报文段包括同步为SYN=1、确认位ACK=1、数据初始序号seq=y以及对客户端发送的请求连接的数据序号进行确认ack=x+1。该报文段也不带数据。\n1.3第三次握手\n客户端接收到服务器发送的连接请求后，会再一次发送一个普通的TCP确认报文段，该报文段包括确认位ACK=1、序号为seq=x+1和对服务器发送的连接请求的序号进行确认ack=y+1\n是否能该为两次握手？\nhttp://mms1.baidu.com/it/u=1000137709,1837952337&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=650&amp;h=394\n不能，因为有可能在TCP客户端发送的请求连接报文段没有被服务端接收，滞留在网络中。然后超时重传一个客户端TCP请求连接报文段，该报文段被正确接收了，此时服务器已经进入了连接状态，并给客户端发送一个确认报文段，客户端接收到后就进入了已连接状态，并开始传输数据，直到释放连接之后，之前停留在网络中的客户端发送的TCP请求连接报文段被服务器正确接收到了，进入连接状态，等待客户端传输数据，但是此时客户端已经关闭了，但是负端并不知道，一直在等待，这就造成了大量资源的浪费。\n2. 释放连接的四次挥手，如下图所示\nhttp://mms0.baidu.com/it/u=783305891,4023764011&amp;fm=253&amp;app=138&amp;f=PNG&amp;fmt=auto&amp;q=75?w=499&amp;h=217\n2.1第一次挥手\n客户端发送一个释放连接TCP数据报文段，该报文段包括释放连接标记FIN=1、确认位ACK=1（已收到服务器上一次传来的数据）、序号位seq=u（u=客户端传输数据结束后的序号位置+1）确认序号ack=v（v=服务器传来数据时的序号+1）。进入终止连接状态1\n2.2第二次挥手\n服务器进入关闭等待状态，并向客户端发送一条普通的TCP确认报文段，该报文段包括确认位ACK=1、序号位seq=v（v=服务器当前数据的序号），确认序号ack=u+1（对客户端第一次传来的释放连接请求序号进行确认）。此时服务器还有数据没有传输完则会继续传输数据给客户端，客户端进入终止等待状态2\n2.3第三次挥手\n服务器没有数据后会向客户端发送一条TCP释放连接报文段，该报文段包括终止连接FIN=1、确认位ACK=1、序号位seq=w（w=当前服务器传输完数据之后的序号位）、ack=u+1。进入确认状态。\n2.4第四次挥手\n客户端回向服务器发送一个TCP确认报文段，该报文段包括确认位ACK=1、序号位seq=u+1（客户端当前数据位序号+1）、确认序号ack=w+1（服务器数据序号位+1）。服务器收到该报文段后就关闭连接了，而客户端则进入时间等待状态等待2MSL， 在进行等待的两分钟内没有收到服务器的报文段就关闭连接了\n2MSL等待是否有必要？\nhttp://mms2.baidu.com/it/u=1928664029,132608216&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=222\n假如客户端最后发送的对服务器的确认报文段在网络中丢失了，服务器并没有收到来自客户端的确认报文段，然后继续向和客户端发送释放连接报文段，但是客户端已经关闭了，不在接收报文段，这就会导致服务器一直处于最后确认状态而不能关闭\n","categories":["network"],"tags":[]},{"title":"go-reflect","url":"/go-reflect/","content":" go-reflect\n 反射的类型对象（reflect.Type)\nreflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type）\n  var a int\ntypeOfA := reflect.TypeOf(a)\n  fmt.Println(typeOfA.Name(), typeOfA.Kind())\t\t\t// int int\n\n  switch typeofA.Kind() &#123;\n  case reflect.String:\n    fmt.Println(\"typeofA type String\",typeofA.Kind()==reflect.String)\n  case reflect.Int:\n    fmt.Println(\"typeofA type Int\",typeofA.Kind()==reflect.Int)\n  default: \n    fmt.Println(\"date can not check\")\n  &#125;\n 反射的类型（Type）与种类（Kind）\n 反射种类（Kind）的定义\nGo语言程序中的类型（Type）指的是系统原生数据类型，以及使用 type 关键字定义的类型\n(这些类型的名称就是其类型本身的名称)。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。\n type A struct &#123;&#125;\n\n TA := reflect.TypeOf(A&#123;&#125;)\t\t\t\t\t// main.A\n Pta := &amp;A&#123;&#125;\t\t\t\t\t\t\t\t\t\t\t\t// 指针\n refPta := reflect.TypeOf(Pta)\t\t\t// *main.A\n fmt.Println(TA.Kind())\t\t\t\t\t\t// struct\n fmt.Println(refPta.Name(),refPta.Kind())\t// '' ptr\nrefPta = refPta.Elem()\t\t\t\t\t\t// 指针所对应的值--类型的元素\n 使用反射获取结构体的成员类型\n\n\n\n方法\n说明\n\n\n\n\nField(i int)StructField\n根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机\n\n\nNumField() int\n返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机\n\n\nFieldByName(name string) (StructField, bool)\n根据给定字符串返回字符串对应的结构体字段的信息，没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机\n\n\nFieldByIndex(index []int) StructField\n多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机\n\n\nFieldByNameFunc(match func(string) bool) (StructField,bool)\n根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机\n\n\n\nStructField 的结构如下：\ntype StructField struct &#123;\n    Name string          // 字段名\n    PkgPath string       // 字段路径\n    Type      Type       // 字段反射类型对象\n    Tag       StructTag  // 字段的结构体标签\n    Offset    uintptr    // 字段在结构体中的相对偏移\n    Index     []int      // Type.FieldByIndex中的返回的索引值\n    Anonymous bool       // 是否为匿名字段\n&#125;\n 结构体标签（Struct Tag）\n通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（StructTag）。结构体标签是对结构体字段的额外信息标签。\n 结构体标签的格式\n&#96;key1:&quot;value1&quot; key2:&quot;value2&quot;&#96;\n结构体标签由一个或多个键值对组成；键与值使用冒号分隔，值用双引号括起来；键值对之间使用一个空格分隔。\n 从结构体标签中获取值\nStructTag 拥有一些方法，可以进行 Tag 信息的解析和提取\n\nfunc (tag StructTag) Get(key string) string：根据 Tag 中的键获取对应的值，例如key1:&quot;value1&quot; key2:&quot;value2&quot;的 Tag 中，可以传入“key1”获得“value1”。\nfunc (tag StructTag) Lookup(key string) (value string, ok bool)：根据 Tag 中的键，查询值是否存在。\n\n","categories":["go"],"tags":[]},{"title":"go module","url":"/go-module/","content":" go-module\n 1.module运行和使用\n 1.1 查看环境变量\ngo env\n 1.2 设置go Modules运行\ngo env -w GO111MODULE&#x3D;on\ngo env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct\n配置环境变量 GO111MODULE：有三个可选值： off、 on、 auto，默认值是 auto。\n\nGO111MODULE=off，无模块支持，go会从 GOPATH 和 vendor 文件夹寻找包。\nGO111MODULE=on，模块支持，go会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod下载依赖。\nGO111MODULE=auto，在 $GOPATH/src外面且根目录有 go.mod文件时，开启模块支持\n\n 1.3 go 使用的基本命令\n\ngo mod init       // 在当前目录初始化mod\ngo mod download  //下载依赖包 下载modules到本地cache 包在 GOPATH/pkg/mod 目录中，而且是只读文件\ngo mod vendor     //将依赖复制到vendor下 ，会生成vendor文件夹 该文件夹下将会放置你go.mod文件描述的依赖包，文件夹下同时还有一个文件modules.txt\ngo mod verify       //验证依赖项是否达到预期的目的\n如果所有的模块都没有被修改过，那么执行这条命令之后，会打印all modules verified\ngo mod tidy        //添加缺失的模块以及移除无用的模块 执行后会生成go.sum文件\ngo mod tidy -v      //可以将执行的信息，即删除和添加的包打印到命令行\ngo mod graph      //打印模块依赖图\ngo mod why       //解释为什么需要依赖\n\n 1.4 go.mod文件内容解释\n​\tgo.mod 提供了module, require、replace和exclude四个命令\n\n\nmodule语句指定包的名字（路径）\n\n\nrequire语句指定的依赖项模块\n\n\nreplace语句可以替换依赖项模块\n\n\nexclude语句可以忽略依赖项模块\n\n\n 2. work\n 2.1 命令使用\ngo work init .&#x2F;xxx .&#x2F;xx\ngo use .&#x2F;xxxx \n命令如下：\ngo work init ./mod ./tools\n项目结构：\nawersomeProject\n\tmod\n\t\tgo.mod\n\t\tmain.go\n\tgo.work\n    tools\n    \tfish.go\n    \tgo.mod\n生产work如下：\ngo 1.18\n\nuse (\n\t./mod\n\t./tools\n)\n 2.2 如何创建工作区并使用\n1、打开终端，进去home目录\ncd\nmkdir workspace_test &amp;&amp; cd workspace_test\n2、module 初始化\n创建一个依赖于http://golang.org/x/example模块的新模块 hello\nmkdir hello &amp;&amp; cd hello\ngo mod init example.com/hello\n3、使用 go get 添加 http://golang.org/x/example 模块的依赖\ngo get golang.org/x/example\n4、在hello目录下创建 hello.go 文件，内容如下：\npackage main\nimport (\n\t\"fmt\"\n\t\n\t\"golang.org/x/example/stringutil\"\n)\nfunc main() &#123;\n\tfmt.Println(stringutil.Reverse(\"Hello, yuzhou1su\"))\n&#125;\n最后的结构如下：\nHello\n\tgo.mod\n\tgo.sum\t\n\thello.go\n5、我们将创建一个 go.work 文件来指定带有模块的工作区\ngo work init ./hello","categories":["go"],"tags":[]},{"title":"gin-overall","url":"/gin-overall/","content":" Gin-overall\n 1.router\n 1.1 路由定义例子\n// 实例化gin实例对象\nr := gin.Default()\n\n// 定义POST请求，url路径为：/users，绑定saveUser控制器函数\nr.POST(\"/users\", saveUser)\n\n// 定义GET请求，url路径为：/users/:id，(:id是参数，例如/users/10，会匹配这个url模式)，绑定getUser控制器函数\nr.GET(\"/users/:id\", getUser)\n\n// 定义PUT请求\nr.PUT(\"/users/:id\", updateUser)\n\n// 定义DELETE请求\nr.DELETE(\"/users/:id\", deleteUser)\n\n// 控制器函数\nfunc saveUser(c *gin.Context) &#123;\n    c.String(http.StatusOK, \"root login success\")\n&#125;\n\nfunc getUser(c *gin.Context) &#123;&#125;\n\nfunc updateUser(c *gin.Context) &#123;&#125;\n\nfunc deleteUser(c *gin.Context) &#123;&#125;\n 1.2 分组路由\nfunc loginEndpoint(c *gin.Context) &#123;\n\tc.String(http.StatusOK, \"login, root login success\")\n&#125;\nfunc submitEndpoint(c *gin.Context) &#123;&#125;\nfunc readEndpoint(c *gin.Context) &#123;&#125;\n\nfunc main() &#123;\n\t// 设置release模式\n\tgin.SetMode(gin.ReleaseMode)\n\n\t// 设置debug模式\n\t// gin.SetMode(gin.DebugMode)\n\n\trouter := gin.Default()\n\n\t// 创建v1组\n\tv1 := router.Group(\"v1\")\n\t&#123;\n\t\t// v1在这个分组下，注册路由\n\t\tv1.POST(\"/login\", loginEndpoint)\n\t\tv1.POST(\"/submit\", submitEndpoint)\n\t\tv1.POST(\"/read\", readEndpoint)\n\t&#125;\n\n\t// 创建v2组\n\tv2 := router.Group(\"v2\")\n\t&#123;\n\t\t// v2在这个分组下，注册路由\n\t\tv2.POST(\"/login\", loginEndpoint)\n\t\tv2.POST(\"/submit\", submitEndpoint)\n\t\tv2.POST(\"/read\", readEndpoint)\n\t&#125;\n\n\trouter.Run(\":8000\")\n&#125;\n 2.处理请求参数\n 2.1 获取Get请求参数\n获取Get请求参数的常用函数：\nfunc (c *Context) Query(key string) string\nfunc (c *Context) DefaultQuery(key, defaultValue string) string\nfunc (c *Context) GetQuery(key string) (string, bool)\nfunc Handler(c *gin.Context) &#123; \n    // 获取name参数, 通过Query获取的参数值是String类型。\n    name := c.Query(\"name\")\n   \n    // 获取name参数, 跟Query函数的区别是，可以通过第二个参数设置默认值。\n    name := c.DefaultQuery(\"name\", \"03xiaomao\")\n    \n    // 获取id参数, 通过GetQuery获取的参数值也是String类型, \n    // 区别是GetQuery返回两个参数，第一个是参数值，第二个参数是参数是否存在的bool值，可以用来判断参数是否存在。\n    id, ok := c.GetQuery(\"id\") \n    if !ok &#123;\n        // 参数不存在\n    &#125;\n    // GetQuery函数，判断参数是否存在的逻辑是，参数值为空，参数也算存在，只有没有提交参数，才算参数不存在。\n&#125;\n 2.2 获取Post请求参数\n// 获取Post请求参数的常用函数：\nfunc (c *Context) PostForm(key string) string\nfunc (c *Context) DefaultPostForm(key, defaultValue string) string\nfunc (c *Context) GetPostForm(key string) (string, bool)\nfunc Handler(c *gin.Context) &#123;\n    // 获取name参数, 通过PostForm获取的参数值是String类型。\n    name := c.PostForm(\"name\")\n    \n    // 跟PostForm的区别是可以通过第二个参数设置参数默认值\n    name := c.DefaultPostForm(\"name\", \"03xiaomao\")\n    \n    // 获取id参数, 通过GetPostForm获取的参数值也是String类型,\n    // 区别是GetPostForm返回两个参数，第一个是参数值，第二个参数是参数是否存在的bool值，可以用来判断参数是否存在。\n    id, ok := c.GetPostForm(\"id\")\n    if !ok &#123;\n        // 参数不存在\n    &#125;\n&#125;\n 2.3 获取URL路径参数\n// 获取url路径参数常用函数：\nfunc (c *Context) Param(key string) string\nr := gin.Default()\nr.GET(\"/user/:id\", func(c *gin.Context) &#123;\n    // 获取url参数id\n    id := c.Param(\"id\")\n&#125;)\n 2.4 将请求参数绑定struct对象\n前面获取参数的方式都是一个个参数的读取，比较麻烦。\nGin框架支持将请求参数自动绑定到一个struct对象，这种方式支持Get/Post请求，也支持http请求body内容为json/xml格式的参数。\nGin提供了两类绑定方法：\n\n\nMust bind\n\n\nMethods - Bind, BindJSON, BindXML, BindQuery, BindYAML\n\n\nBehavior - 这些方法属于 MustBindWith 的具体调用。 如果发生绑定错误，则请求终止，并触发 c.AbortWithError(400, err).SetType(ErrorTypeBind)。响应状态码被设置为 400 并且 Content-Type 被设置为 text/plain; charset=utf-8。 如果您在此之后尝试设置响应状态码，Gin会输出日志 [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422。 如果您希望更好地控制绑定，考虑使用 ShouldBind 等效方法。\n\n\n\n\nShould bind\n\nMethods - ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML\n**Behavior - **这些方法属于 ShouldBindWith 的具体调用。 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。\n\n\n\ntype User struct &#123;\n\tName string `json:\"name\" form:\"name\"`\n\tEmail string `json:\"email\" form:\"email\"`\n&#125;\nr.POST(\"/user/:id\", func(c *gin.Context) &#123;\n    // 初始化 user struct\n    u := User&#123;&#125;\n    \n    // 通过 ShouldBind 函数，将请求参数绑定到 struct 对象， 处理 json 请求代码是一样的。\n    // 如果是 post 请求则根据 Content-Type 判断，接收的是 json 数据，还是普通的 http 请求参数\n    if c.ShouldBind(&amp;u) == nil &#123;\n        // 绑定成功， 打印请求参数\n        log.Println(u.Name)\n        log.Println(u.Email)\n    &#125;\n    \n    // http 请求返回一个字符串 \n    c.String(200, \"Success\")\n&#125;)\n// 如果通过http请求body传递json格式的请求参数，并且通过post请求的方式提交参数，则需要将 Content-Type 设置为 application/json , 如果是xml格式的数据，则设置为 application/xml\n 2.5 获取客户ip\nr := gin.Default()\n\nr.GET(\"/ip\", func(c *gin.Context) &#123;\n    // 获取用户IP\n    ip := c.ClientIP()\n&#125;)\n 3. 返回响应结果\nGin框架支持以字符串、json、xml、文件等格式响应请求。\n 3.1 以字符串方式响应请求\n// 通过String函数返回字符串。\nfunc (c *Context) String(code int, format string, values ...interface&#123;&#125;)\n参数说明：\n\n\n\n参数\n说明\n\n\n\n\ncode\nhttp状态码\n\n\nformat\n返回结果，支持类似Sprintf函数一样的字符串格式定义，例如,%d 代表插入整数，%s代表插入字符串\n\n\nvalues\n任意个format参数定义的字符串格式参数\n\n\n\nfunc Handler(c *gin.Context) &#123;\n    c.String(200, \"欢迎03xiaomao\")\n    c.String(200, \"欢迎%s\", 03xiaomao)\n&#125;\n 3.2 以json、xml格式响应请求\n开发api接口的时候常用的格式就是json :\n// User 定义\ntype User struct &#123;\n    Name string `json:\"name\" xml:\"name\"` \t// 通过json标签定义struct字段转换成json字段的名字\n    Email string `json:\"email\" xml:\"email\"`\n&#125;\n\n// Handler 控制器\nfunc (c *gin.Context) &#123;\n    // 初始化user对象\n    u := &amp;User&#123;\n        Name: \"03xiaomao\"\n        Email: \"03xiaomao\"\n    &#125;\n    \n    // 返回json数据\n    c.JSON(200, u)\n    // c.XML(200, u)\n&#125;\n 3.3 以文件格式响应请求\n下面介绍gin框架如何直接返回一个文件，可以用来做文件下载。\nfunc (c *gin.Context) &#123;\n    // 通过File函数，直接返回本地文件，参数为本地文件地址。\n    // 函数说明：c.File(\"文件路径\")\n    c.File(\"/var/www/1.jpg\")\n&#125;\nfunc (c *gin.Context) &#123;\n    // 通过FileAttachment函数，返回本地文件，类似File函数，区别是可以指定下载的文件名。\n    // 函数说明: c.FileAttachment(\"文件路径\", \"下载的文件名\")\n    c.FileAttachment(\"/var/www/1.jpg\", \"1.jpg\")\n&#125;\n 3.4 设置http响应头\n设置Header：\nfunc (c *gin.Context) &#123;\n    // 设置http响应 header, key/value方式，支持设置多个header\n\tc.Header(\"site\", \"03xiaomao\")\n&#125;\n 4. html模板处理\n 4.1 返回html结果的例子\nfunc main() &#123;\n\t// 初始化gin对象\n    router := gin.Default()\n    \n    // 首先加载templates目录下面的所有模版文件，模版文件扩展名随意\n    router.LoadHTMLGlob(\"templates/*\")\n    \n    // 绑定一个url路由 /index\n    router.GET(\"/index\", func(c *gin.Context) &#123;\n        // 通过HTML函数返回html代码\n        // 第二个参数是模版文件名字\n        // 第三个参数是map类型，代表模版参数\n        // gin.H 是 map[string]interface&#123;&#125; 类型的别名\n        c.HTML(http.StatusOk, \"index.html\", gin.H&#123;\n            \"title\": \"Main website\",\n        &#125;)\n    &#125;)\n    \n    // 启动http服务，并且绑定在8080端口\n    router.Run(\":8080\")\n&#125;\n模板代码\n文件名：templates/index.html\n&lt;html>\n\t&lt;h1>\n\t\t&#123;&#123; .title &#125;&#125;\n\t&lt;/h1>\n&lt;/html>\n 4.2 处理模版子目录的情况\n一般在项目中，因为有多个模块的模版文件，则以多个子目录的方式来组织模版文件，上面的例子只能加载某个目录下面的模版文件，无法加载子目录的模版文件。\nfunc main() &#123;\n\trouter := gin.Default()\n\t\n    // 加载templates目录下面的所有模版文件，包括子目录\n    // **/* 代表所有子目录下的所有文件\n    router.LoadHTMLGlob(\"templates/**/*\")\n    \n    router.GET(\"/posts/index\", func(c *gin.Context) &#123;\n        // 子目录的模版文件，需要加上目录名，例如：posts/index.tmpl\n        c.HTML(http.StatusOK, \"posts/index.tmpl\", gin.H&#123;\n            \"title\": \"Posts\",\n        &#125;)\n    &#125;)\n    \n    router.GET(\"/users/index\", func(c *gin.Context) &#123;\n        // 子目录的模版文件，需要加上目录名，例如：users/index.tmpl\n        c.HTML(http.StatusOK, \"users/index.tmpl\", gin.H&#123;\n            \"title\": \"Users\",\n        &#125;)\n    &#125;)\n    \n    router.Run(\":8080\")\n&#125;\n模版文件：templates/posts/index.tmpl\n&#123;&#123; define \"posts/index.tmpl\" &#125;&#125;\n&lt;html>\n\t&lt;h1>\n\t\t&#123;&#123; .title &#125;&#125;\n\t&lt;/h1>\n\t&lt;p>Using posts/index.tmpl&lt;/P>\n&lt;/html>\n&#123;&#123; end &#125;&#125;\n模版文件：templates/users/index.tmpl\n&#123;&#123; define \"users/index.tmpl\" &#125;&#125;\n&lt;html>\n\t&lt;h1>\n\t\t&#123;&#123; .title &#125;&#125;\n\t&lt;/h1>\n\t&lt;p>Using users/index.tmpl&lt;/P>\n&lt;/html>\n&#123;&#123; end &#125;&#125;\n 5. 访问静态资源文件\nfunc main() &#123;\n\trouter := gin.Default()\n    \n\t// 设置静态资源文件目录，并且绑定一个Url前缀\n    // 静态资源文件目录：/var/www/tizi365/assets\n    // /assets是访问静态资源的url前缀\n    // /assets/images/1.jpg 这个url文件，存储在/var/www/tizi365/assets/images/1.jpg\n\trouter.Static(\"/assets\", \"/var/www/03xiaomao/assets\")\n    \n    // 为单个静态资源文件，绑定url\n    // 这里的意思就是将/favicon.ico这个url，绑定到./resources/favicon.ico这个文件\n    router.StaticFile(\"/favicon.ico\", \"./resources/favicon.ico\")\n    \n    // Listen and serve on 0.0.0.0:8080\n    router.Run(\":8080\")\n&#125;\n// 设置 /favicon.ico 这个url，其实就是为网站设置图标，浏览器默认会将这个url作为网站默认图标。\n 6. 处理cookie\ncookie通常用于在浏览器中保存一些小数据，例如客户标识、用户非敏感数据。\ngin框架主要通过上下文对象提供的 SetCookie和Cookie两个函数操作cookie\n 6.1 设置cookie\nSetCookie函数定义：\nfunc (c *context) SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool) &#123;&#125;\n参数说明：\n\n\n\n参数名\n类型\n说明\n\n\n\n\nname\nstring\ncookie名字\n\n\nvalue\nstring\ncookie值\n\n\nmaxAge\nint\n有效时间，单位是秒，MaxAge=0 忽略MaxAge属性，MaxAge&lt;0 相当于删除cookie, 通常可以设置-1代表删除，MaxAge&gt;0 多少秒后cookie失效\n\n\npath\nstring\ncookie路径\n\n\ndomain\nstring\ncookie作用域\n\n\nsecure\nbool\nSecure=true，那么这个cookie只能用https协议发送给服务器\n\n\nhttpOnly\nbool\n设置 HttpOnly=true 的cookie不能被js获取到\n\n\n\n 6.2 读取cookie\nfunc Handler(c *gin.Context) &#123;\n    // 根据cookie名字读取cookie值\n\tdata, err := c.Cookie(\"site_cookie\")\n    if err != nil &#123;\n        // 直接返回cookie值\n        c.String(200, data)\n    \treturn\n    &#125;\n    c.String(200, \"not found!\")\n&#125;\n 6.3 删除cookie\nfunc Handler(c *gin.Context) &#123;\n    c.SetCookie(\"site_cookie\",\"cookievalue\", -1, \"/\", \"localhost\", false, true)\n    c.String(200, \"删除cookie演示\")\n&#125;\n 7. 文件上传\nfunc main() &#123;\n    router := gin.Default()\n    \n    // 设置文件上传大小限制，默认是32m\n    router.MaxMultipartMemory = 64 &lt;&lt; 20\t// 64Mib \n    \n    router.POST(\"/upload\", func(c *gin.Context) &#123;\n        // 获取上传文件，返回的是multipart.FileHeader对象，代表一个文件，里面包含了文件名之类的详细信息\n        // file 是表单字段名字\n        file, _ := c.FormFile(\"file\")\n        \n        // 打印上传的文件名\n        log.Println(file.Filename)\n        \n        // 将上传的文件，保存到 ./data/1111.jpg 文件中\n        c.SaveUploadedFile(file, \"./data/1111.jpg\")\n        \n        c.String(http.StatusOK, fmt.Sprintf(\"'%s' uploaded!\", file.Filename))\n    &#125;)\n    router.Run(\":8080\")\n&#125;\n&lt;form action=\"/upload\" method=\"post\" enctype=\"mutipart/form-data\">\n     文件: &lt;input type=\"file\" name=\"file\">&lt;br>&lt;br>\n     &lt;input type=\"submit\" value=\"文件上传\">\n&lt;/form>\n 8. 中间件\n在Gin框架中，中间件（Middleware）指的是可以拦截http请求-响应生命周期的特殊函数，在请求-响应生命周期中可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。\n中间件的常见应用场景如下：\n\n请求限速\napi接口签名处理\n权限校验\n统一错误处理\n\nGin支持设置全局中间件和针对路由分组设置中间件:\n\n全局中间件会拦截所有请求\n分组路由设置中间件，仅对这个分组下的路由起作用\n\n 8.1 使用中间件\nfunc main() &#123;\n\tr := gin.New()\n\t\n\t// 通过use设置全局中间件\n\t// 设置日志中间件，主要用于打印请求日志\n\tr.Use(gin.Logger())\n\t\n\t// 设置Recovery中间件，主要用于拦截paic错误，不至于导致进程崩掉\n\tr.Use(gin.Recovery())\n&#125;\n 8.2 自定义中间件\nfunc Logger() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n        t := time.Now()\n        \n        // 可以通过上下文对象，设置一些依附在上下文对象里面的键/值数据\n        c.Set(\"example\", \"12345\")\n        \n        // 在这里处理请求到达控制器函数之前的逻辑\n        // 调用下一个中间件，或者控制器处理函数，具体得看注册了多少个中间件。\n        c.Next()\n        \n        // 在这里可以处理请求返回给用户之前的逻辑\n        latency := time.Since(t)\n        log.Print(latency)\n        \n        // 例如，查询请求状态ma\n        status := c.Writer.Status()\n        log.Println(status)\n    &#125;\n&#125;\n\nfunc main() &#123;\n    r := gin.New()\n    \n    // 注册上面自定义的日志中间件\n    r.Use(Logger())\n    \n    r.GET(\"/test\", func(c *gin.Context) &#123;\n        \n        // 查询我们之前在日志中间件，注入的键值数据\n        example := c.MustGet(\"example\").(string)\n        \n        // it would print: \"12345\"\n        log.Println(example)\n    &#125;)\n    \n    // Listen and serve on 0.0.0.0:8080\n    r.Run(\":8080\")\n&#125;\n 9. 处理session\n在Gin框架中，依赖 gin-contrib/sessions中间件处理session。\ngin-contrib/sessions中间件支持的存储引擎：\n\ncookie\nmemstore\nredis\nmemcached\nmongodb\n\n 9.1 安装session包\ngo get github.com&#x2F;gin-contrib&#x2F;sessions\n 9.2 基本的session用法\nfunc main() &#123;\n\tr := gin.Default()\n\t\n    // 创建基于cookie的存储引擎，secret11111 参数是用于加密的密钥\n\tstore := cookie.NewStore([]byte(\"secret11111\"))\n\t\n    // 设置session中间件，参数mysession，指的是session的名字，也是cookie的名字\n    // store是前面创建的存储引擎，可以替换成其他存储引擎\n    r.Use(sessions.Sessions(\"mysession\", store))\n    \n    r.GET(\"/hello\", func(c *gin.Context) &#123;\n        // 初始化session对象\n        session := sessions.Default(c)\n        \n        // 通过session.Get读取session值\n        // session是键值对格式数据，因此需要通过key查询数据\n        if session.Get(\"hello\") != \"world\" &#123;\n            // 设置session数据\n            session.Set(\"hello\", \"world\")\n            // 删除session数据\n            session.Delete(\"03xiaomao\")\n            // 保存session数据\n            session.Save()\n            // 删除整个session\n            // session.Clear()\n        &#125;\n        \n        c.JSON(200, gin.H&#123;\"hello\": session.Get(\"hello\")&#125;)\n    &#125;)\n    r.Run(\":8000\")\n&#125;\n 9.3 基于redis存储引擎的session\n如果想将session数据保存到redis中，只要将session的存储引擎改成redis即可。\n使用redis作为存储引擎的例子：\n首先安装redis存储引擎的包\ngo get github.com&#x2F;gin-contrib&#x2F;sessions&#x2F;redis\npackage main\n\nimport (\n\t\"github.com/gin-contrib/sessions\"\n    \"github.com/gin-contrib/sessions/redis\"\n    \"github.com/gin-gonic/gin\"\n)\n\nfunc main() &#123;\n\tr := gin.Default()\n    \n    // 初始化基于redis的存储引擎\n    // 参数说明：\n    //    第1个参数 - redis最大的空闲连接数\n    //    第2个参数 - 数通信协议tcp或者udp\n    //    第3个参数 - redis地址, 格式，host:port\n    //    第4个参数 - redis密码\n    //    第5个参数 - session加密密钥\n    store, _ := redis.NewStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\t\n\tr.GET(\"/incr\", func(c *gin.Context) &#123;\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil &#123;\n\t\t\tcount = 0\n\t\t&#125; else &#123;\n\t\t\tcount = v.(int)\n\t\t\tcount++\n\t\t&#125;\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H&#123;\"count\": count&#125;)\n\t&#125;)\n\tr.Run(\":8000\")\n&#125;\n// netstat -aon | findstr :端口\n// 查看该端口下的应用\n","categories":["gin"],"tags":[]},{"title":"gin-install","url":"/gin-install/","content":" Gin-install\n 1. 安装\n\n\n开启 go module\nset GO111MODULE&#x3D;on\n\n\n切换代理\ngo env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct\n\n\n下载并安装 gin：\ngo get -u github.com&#x2F;gin-gonic&#x2F;gin\n\n\n将 gin 引入到代码中：\nimport &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\n\n（可选）如果使用诸如 http.StatusOK 之类的常量，则需要引入 net/http 包：\nimport &quot;net&#x2F;http&quot;\n\n\n 2. 运行项目\n\n\n创建你的项目文件夹并 cd 进去\n$ mkdir -p $GOPATH&#x2F;src&#x2F;github.com&#x2F;myusername&#x2F;project &amp;&amp; cd &quot;$_&quot;\n\n\n拷贝一个初始模板到你的项目里\n$ curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gin-gonic&#x2F;examples&#x2F;master&#x2F;basic&#x2F;main.go &gt; main.go\n\n\n运行你的项目\n$ go run main.go\n\n\n 3. 一个典型的MVC框架：\n​\tGin框没有对项目结构做出限制，因此可以根据项目需要自行设计。\n-- conf\n\t-- config.toml\n-- controllers\n\t-- food.go\n\t-- user.go\n-- main.go\n-- models\n\t-- food.go\n\t-- user.go\nstatic\n\t-- css\n\t-- images\n\t-- js\n-- logs\n-- views\n\t-- index.html\n 4. Gin框架运行模式\n​\t为了方便调试，Gin 框架在运行的时候默认是debug模式，在控制台默认会打印出很多调试日志。\n​\t上线的时候需要关闭debug模式，改为release模式。\n​\t设置Gin框架运行模式：\n\n\n通过环境变量设置\nexport GIN_MODE&#x3D;release &#x2F; debug\n\n\n通过代码设置\n在main函数，初始化gin框架的时候执行下面代码\n\n// 设置 release模式\ngin.SetMode(gin.ReleaseMode)\n\n// 或者 设置debug模式\ngin.SetMode(gin.DebugMode)\n\n\n","categories":["gin"],"tags":[]}]